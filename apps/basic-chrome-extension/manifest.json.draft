// For more information on the contents here:
// https://developer.chrome.com/docs/extensions/mv3/getstarted/

// This is the most basic format of manifest.json
// For 'manifest_version', always use version 2 or above
// 'version' is the version of the Extension

{
  "manifest_version": 2,
  "name": "Basic Chrome Extension",
  "version": "0.1.0"
}

// When you add script files, make manifest.json aware of their existence
// This tells Chrome to inject 'content.js' into every page we visit using the special '<all_urls>' URL pattern
// If we want to inject the script on only some pages, we can use match patterns. Example:
//   ["https://mail.google.com/*", "http://mail.google.com/*"]

// Make sure to add `/*` in order to account for all sub-pages
// `http://*/*` will match any http URL, but no other scheme
// `https://*/*` will match any https URL, but no other scheme
// Use `<all_urls>` to match every single web page

{
  "manifest_version": 2,
  "name": "Basic Chrome Extension",
  "version": "0.1.0",
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["content.js"]
  }]
}

// We can add dependency libraries if needed
// For example, if you extension depended on jQuery, we could do:
// Make sure the the library is part of the extension as well

{
  "manifest_version": 2,
  "name": "Basic Chrome Extension",
  "version": "0.1.0",
  "content_scripts": [{
      "matches": ["<all_urls>"],
      "js": ["scripts/jquery.min.js", "scripts/content.js"]
  }]
}

// A Browser Action is the small icon that is added on the Browser Extensions Bar
// We can set this using a small icon PNG file

"browser_action": {
  "default_icon": {
    "16": "icons/icon_16.png",
    "32": "icons/icon_32.png",
    "48": "icons/icon_48.png",
    "128": "icons/icon_128.png"
  }
}

// In order to use the browser action, we need to add message passing
// A content script has access to the current page, but is limited in the APIs it can access
// It cannot listen for clicks on the Browser Action button
// We need to add a background script instead
// A background script has access to every Chrome API but cannot access the current page
// The content script will be able to pull a URL out of the current page
// But will need to hand that URL over to the background script to do something useful with it
// We will use Message Passing -- allows scripts to send and listen for messages
// It is the only way for content scripts and background scripts to interact

"background": {
  "scripts": ["background.js"]
}

// Now, Every time you click the browser action icon, 
// you should see a URL get logged to the console
// If we wanted to open a new tab, we can use the `chrome.tabs` API

// But chrome.tabs can only be used by background.js
// So we’ll have to add some more message passing since background.js can open the tab
// But can’t grab the URL

// The general idea is:
// 1 - Listen for a click on the browser action in background.js. 
//     When it’s clicked, send a clicked_browser_action event to content.js.
// 2 - When content.js receives the event, it grabs the URL of the first link on the page. 
//     Then it sends open_new_tab back to background.js with the URL to open.
// 3 - background.js listens for open_new_tab 
//     and opens a new tab with the given URL when it receives the message.
